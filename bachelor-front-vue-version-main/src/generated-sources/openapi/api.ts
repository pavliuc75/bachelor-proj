/* tslint:disable */
/* eslint-disable */
/**
 * bloom backend open api specification
 * bloom backend open api specification
 *
 * The version of the OpenAPI document: 1.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddProductToCartRequest
 */
export interface AddProductToCartRequest {
    /**
     * 
     * @type {string}
     * @memberof AddProductToCartRequest
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof AddProductToCartRequest
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface AddRemoveProductToWishlistRequest
 */
export interface AddRemoveProductToWishlistRequest {
    /**
     * 
     * @type {string}
     * @memberof AddRemoveProductToWishlistRequest
     */
    'productId'?: string;
}
/**
 * 
 * @export
 * @interface AppUser
 */
export interface AppUser {
    /**
     * 
     * @type {string}
     * @memberof AppUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppUser
     */
    'businessApplicationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppUser
     */
    'businessId'?: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof AppUser
     */
    'roles'?: Array<Role>;
    /**
     * 
     * @type {Cart}
     * @memberof AppUser
     */
    'cart'?: Cart;
    /**
     * 
     * @type {Wishlist}
     * @memberof AppUser
     */
    'wishlist'?: Wishlist;
    /**
     * 
     * @type {Array<UserProductRating>}
     * @memberof AppUser
     */
    'ratedProductList'?: Array<UserProductRating>;
}
/**
 * 
 * @export
 * @interface Author
 */
export interface Author {
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Author
     */
    'isProductOwner'?: boolean;
}
/**
 * 
 * @export
 * @interface AutocompleteProductResponseInner
 */
export interface AutocompleteProductResponseInner {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteProductResponseInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteProductResponseInner
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof AutocompleteProductResponseInner
     */
    'price'?: number;
    /**
     * 
     * @type {ProductImage}
     * @memberof AutocompleteProductResponseInner
     */
    'mainImage'?: ProductImage;
}
/**
 * 
 * @export
 * @interface Business
 */
export interface Business {
    /**
     * 
     * @type {string}
     * @memberof Business
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Business
     */
    'ownerUserId'?: string;
    /**
     * 
     * @type {BusinessState}
     * @memberof Business
     */
    'businessState'?: BusinessState;
    /**
     * 
     * @type {BusinessDescription}
     * @memberof Business
     */
    'businessDescription': BusinessDescription;
    /**
     * 
     * @type {BusinessPaymentDetails}
     * @memberof Business
     */
    'businessPaymentDetails': BusinessPaymentDetails;
    /**
     * 
     * @type {BusinessLegalDocuments}
     * @memberof Business
     */
    'businessLegalDocuments': BusinessLegalDocuments;
    /**
     * 
     * @type {BusinessContacts}
     * @memberof Business
     */
    'businessContacts'?: BusinessContacts;
    /**
     * 
     * @type {BusinessLogo}
     * @memberof Business
     */
    'businessLogo'?: BusinessLogo;
    /**
     * 
     * @type {string}
     * @memberof Business
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Business
     */
    'lastModifiedDate'?: string;
}
/**
 * 
 * @export
 * @interface BusinessApplication
 */
export interface BusinessApplication {
    /**
     * 
     * @type {string}
     * @memberof BusinessApplication
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplication
     */
    'createdBusinessId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplication
     */
    'creatorUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplication
     */
    'reviewId'?: string;
    /**
     * 
     * @type {BusinessApplicationState}
     * @memberof BusinessApplication
     */
    'businessApplicationState'?: BusinessApplicationState;
    /**
     * 
     * @type {BusinessDescription}
     * @memberof BusinessApplication
     */
    'businessDescription': BusinessDescription;
    /**
     * 
     * @type {BusinessPaymentDetails}
     * @memberof BusinessApplication
     */
    'businessPaymentDetails': BusinessPaymentDetails;
    /**
     * 
     * @type {BusinessLegalDocuments}
     * @memberof BusinessApplication
     */
    'businessLegalDocuments': BusinessLegalDocuments;
    /**
     * 
     * @type {BusinessContacts}
     * @memberof BusinessApplication
     */
    'businessContacts'?: BusinessContacts;
    /**
     * 
     * @type {BusinessLogo}
     * @memberof BusinessApplication
     */
    'businessLogo'?: BusinessLogo;
}
/**
 * 
 * @export
 * @interface BusinessApplicationListResponse
 */
export interface BusinessApplicationListResponse {
    /**
     * 
     * @type {Array<BusinessApplication>}
     * @memberof BusinessApplicationListResponse
     */
    'businessApplicationPageList'?: Array<BusinessApplication>;
    /**
     * 
     * @type {number}
     * @memberof BusinessApplicationListResponse
     */
    'totalAmountOfPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof BusinessApplicationListResponse
     */
    'totalAmountOfElements'?: number;
}
/**
 * 
 * @export
 * @interface BusinessApplicationReview
 */
export interface BusinessApplicationReview {
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationReview
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationReview
     */
    'BusinessApplicationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationReview
     */
    'ReviewAuthorId'?: string;
    /**
     * 
     * @type {BusinessReviewState}
     * @memberof BusinessApplicationReview
     */
    'businessReviewState'?: BusinessReviewState;
    /**
     * 
     * @type {string}
     * @memberof BusinessApplicationReview
     */
    'businessReviewDescription'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BusinessApplicationState = {
    InReview: 'InReview',
    Approved: 'Approved',
    Denied: 'Denied'
} as const;

export type BusinessApplicationState = typeof BusinessApplicationState[keyof typeof BusinessApplicationState];


/**
 * 
 * @export
 * @interface BusinessContacts
 */
export interface BusinessContacts {
    /**
     * 
     * @type {number}
     * @memberof BusinessContacts
     */
    'phoneNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof BusinessContacts
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessContacts
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessContacts
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessContacts
     */
    'facebook'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessContacts
     */
    'instagram'?: string;
}
/**
 * 
 * @export
 * @interface BusinessDescription
 */
export interface BusinessDescription {
    /**
     * 
     * @type {string}
     * @memberof BusinessDescription
     */
    'legalName': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessDescription
     */
    'businessEntityType': BusinessDescriptionBusinessEntityTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof BusinessDescription
     */
    'uniqueIdentificationCode': number;
    /**
     * 
     * @type {number}
     * @memberof BusinessDescription
     */
    'tvaNumber': number;
    /**
     * 
     * @type {string}
     * @memberof BusinessDescription
     */
    'companyDescription'?: string;
}

export const BusinessDescriptionBusinessEntityTypeEnum = {
    Srl: 'SRL',
    Sa: 'SA',
    Sc: 'SC',
    Snc: 'SNC',
    Other: 'Other'
} as const;

export type BusinessDescriptionBusinessEntityTypeEnum = typeof BusinessDescriptionBusinessEntityTypeEnum[keyof typeof BusinessDescriptionBusinessEntityTypeEnum];

/**
 * 
 * @export
 * @interface BusinessForAdminListResponse
 */
export interface BusinessForAdminListResponse {
    /**
     * 
     * @type {Array<Business>}
     * @memberof BusinessForAdminListResponse
     */
    'businessPageList'?: Array<Business>;
    /**
     * 
     * @type {number}
     * @memberof BusinessForAdminListResponse
     */
    'totalAmountOfPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof BusinessForAdminListResponse
     */
    'totalAmountOfElements'?: number;
}
/**
 * 
 * @export
 * @interface BusinessForPublicListResponse
 */
export interface BusinessForPublicListResponse {
    /**
     * 
     * @type {Array<BusinessForPublicResponse>}
     * @memberof BusinessForPublicListResponse
     */
    'businessPageList'?: Array<BusinessForPublicResponse>;
    /**
     * 
     * @type {number}
     * @memberof BusinessForPublicListResponse
     */
    'totalAmountOfPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof BusinessForPublicListResponse
     */
    'totalAmountOfElements'?: number;
}
/**
 * 
 * @export
 * @interface BusinessForPublicResponse
 */
export interface BusinessForPublicResponse {
    /**
     * 
     * @type {string}
     * @memberof BusinessForPublicResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessForPublicResponse
     */
    'ownerUserId': string;
    /**
     * 
     * @type {BusinessState}
     * @memberof BusinessForPublicResponse
     */
    'businessState'?: BusinessState;
    /**
     * 
     * @type {BusinessDescription}
     * @memberof BusinessForPublicResponse
     */
    'businessDescription': BusinessDescription;
    /**
     * 
     * @type {BusinessContacts}
     * @memberof BusinessForPublicResponse
     */
    'businessContacts'?: BusinessContacts;
    /**
     * 
     * @type {BusinessLogo}
     * @memberof BusinessForPublicResponse
     */
    'businessLogo'?: BusinessLogo;
    /**
     * 
     * @type {string}
     * @memberof BusinessForPublicResponse
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessForPublicResponse
     */
    'lastModifiedDate'?: string;
}
/**
 * 
 * @export
 * @interface BusinessLegalDocuments
 */
export interface BusinessLegalDocuments {
    /**
     * File key from AWS S3 bucket
     * @type {string}
     * @memberof BusinessLegalDocuments
     */
    'registrationCertificateKey': string;
    /**
     * AWS S3 Object Url to bank statement file
     * @type {string}
     * @memberof BusinessLegalDocuments
     */
    'registrationCertificateFileUrl': string;
    /**
     * File key from AWS S3 bucket
     * @type {string}
     * @memberof BusinessLegalDocuments
     */
    'bankStatementFileKey': string;
    /**
     * AWS S3 Object Url to bank statement file
     * @type {string}
     * @memberof BusinessLegalDocuments
     */
    'bankStatementFileUrl': string;
}
/**
 * 
 * @export
 * @interface BusinessLogo
 */
export interface BusinessLogo {
    /**
     * File key from AWS S3 bucket
     * @type {string}
     * @memberof BusinessLogo
     */
    'logoKey': string;
    /**
     * AWS S3 Object Url to bank statement file
     * @type {string}
     * @memberof BusinessLogo
     */
    'logoFileUrl': string;
}
/**
 * 
 * @export
 * @interface BusinessPaymentDetails
 */
export interface BusinessPaymentDetails {
    /**
     * 
     * @type {string}
     * @memberof BusinessPaymentDetails
     */
    'iban': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessPaymentDetails
     */
    'bank': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessPaymentDetails
     */
    'swiftCode': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BusinessReviewState = {
    Approved: 'Approved',
    Denied: 'Denied'
} as const;

export type BusinessReviewState = typeof BusinessReviewState[keyof typeof BusinessReviewState];


/**
 * 
 * @export
 * @enum {string}
 */

export const BusinessState = {
    Active: 'Active',
    Blocked: 'Blocked'
} as const;

export type BusinessState = typeof BusinessState[keyof typeof BusinessState];


/**
 * 
 * @export
 * @interface Cart
 */
export interface Cart {
    /**
     * 
     * @type {Array<ProductInCart>}
     * @memberof Cart
     */
    'products'?: Array<ProductInCart>;
    /**
     * 
     * @type {number}
     * @memberof Cart
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cart
     */
    'totalPrice'?: number;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface CategoryApplication
 */
export interface CategoryApplication {
    /**
     * 
     * @type {string}
     * @memberof CategoryApplication
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryApplication
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface CategoryApplicationListResponse
 */
export interface CategoryApplicationListResponse {
    /**
     * 
     * @type {Array<CategoryApplication>}
     * @memberof CategoryApplicationListResponse
     */
    'categoryApplicationList'?: Array<CategoryApplication>;
    /**
     * 
     * @type {number}
     * @memberof CategoryApplicationListResponse
     */
    'totalAmountOfPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof CategoryApplicationListResponse
     */
    'totalAmountOfElements'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CategoryApplicationResponse = {
    Approve: 'Approve',
    Deny: 'Deny'
} as const;

export type CategoryApplicationResponse = typeof CategoryApplicationResponse[keyof typeof CategoryApplicationResponse];


/**
 * 
 * @export
 * @interface CategoryListResponse
 */
export interface CategoryListResponse {
    /**
     * 
     * @type {Array<Category>}
     * @memberof CategoryListResponse
     */
    'categoryList'?: Array<Category>;
    /**
     * 
     * @type {number}
     * @memberof CategoryListResponse
     */
    'totalAmountOfPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof CategoryListResponse
     */
    'totalAmountOfElements'?: number;
}
/**
 * 
 * @export
 * @interface CloseSupportThreadRequest
 */
export interface CloseSupportThreadRequest {
    /**
     * 
     * @type {string}
     * @memberof CloseSupportThreadRequest
     */
    'supportThreadId'?: string;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'commentNodeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'productTreeId'?: string;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof Comment
     */
    'children'?: Array<Comment>;
    /**
     * 
     * @type {Author}
     * @memberof Comment
     */
    'author'?: Author;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'createdDate'?: string;
}
/**
 * 
 * @export
 * @interface CommentTreeListResponse
 */
export interface CommentTreeListResponse {
    /**
     * 
     * @type {Array<Comment>}
     * @memberof CommentTreeListResponse
     */
    'commentTreeList'?: Array<Comment>;
    /**
     * 
     * @type {number}
     * @memberof CommentTreeListResponse
     */
    'totalAmountOfPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommentTreeListResponse
     */
    'totalAmountOfElements'?: number;
}
/**
 * 
 * @export
 * @interface CreateBusinessApplicationRequest
 */
export interface CreateBusinessApplicationRequest {
    /**
     * 
     * @type {BusinessDescription}
     * @memberof CreateBusinessApplicationRequest
     */
    'businessDescription': BusinessDescription;
    /**
     * 
     * @type {BusinessPaymentDetails}
     * @memberof CreateBusinessApplicationRequest
     */
    'businessPaymentDetails': BusinessPaymentDetails;
    /**
     * 
     * @type {BusinessLegalDocuments}
     * @memberof CreateBusinessApplicationRequest
     */
    'businessLegalDocuments': BusinessLegalDocuments;
    /**
     * 
     * @type {BusinessContacts}
     * @memberof CreateBusinessApplicationRequest
     */
    'businessContacts'?: BusinessContacts;
    /**
     * 
     * @type {BusinessLogo}
     * @memberof CreateBusinessApplicationRequest
     */
    'businessLogo'?: BusinessLogo;
}
/**
 * 
 * @export
 * @interface CreateBusinessReviewRequest
 */
export interface CreateBusinessReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessReviewRequest
     */
    'businessApplicationId'?: string;
    /**
     * 
     * @type {BusinessReviewState}
     * @memberof CreateBusinessReviewRequest
     */
    'businessReviewState'?: BusinessReviewState;
    /**
     * 
     * @type {string}
     * @memberof CreateBusinessReviewRequest
     */
    'businessReviewDescription'?: string;
}
/**
 * 
 * @export
 * @interface CreateCategoryApplicationRequest
 */
export interface CreateCategoryApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCategoryApplicationRequest
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface CreateCheckoutSession201Response
 */
export interface CreateCheckoutSession201Response {
    /**
     * Redirect url to checkout
     * @type {string}
     * @memberof CreateCheckoutSession201Response
     */
    'redirectUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCheckoutSession201Response
     */
    'success_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCheckoutSession201Response
     */
    'cancel_url'?: string;
}
/**
 * 
 * @export
 * @interface CreateNewCommentReplyRequest
 */
export interface CreateNewCommentReplyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateNewCommentReplyRequest
     */
    'productId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateNewCommentReplyRequest
     */
    'targetCommentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateNewCommentReplyRequest
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface CreateNewCommentRequest
 */
export interface CreateNewCommentRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateNewCommentRequest
     */
    'productId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateNewCommentRequest
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface CreateNewSupportThreadRequest
 */
export interface CreateNewSupportThreadRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateNewSupportThreadRequest
     */
    'topic'?: string;
}
/**
 * 
 * @export
 * @interface CreateNewThreadReplyRequest
 */
export interface CreateNewThreadReplyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateNewThreadReplyRequest
     */
    'supportThreadId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateNewThreadReplyRequest
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface DeleteProductInCartRequest
 */
export interface DeleteProductInCartRequest {
    /**
     * The product id
     * @type {string}
     * @memberof DeleteProductInCartRequest
     */
    'productId'?: string;
}
/**
 * 
 * @export
 * @interface FilterProductBy
 */
export interface FilterProductBy {
    /**
     * 
     * @type {Array<string>}
     * @memberof FilterProductBy
     */
    'category'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof FilterProductBy
     */
    'inStock'?: boolean;
}
/**
 * 
 * @export
 * @interface HandleCategoryApplicationRequest
 */
export interface HandleCategoryApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof HandleCategoryApplicationRequest
     */
    'categoryId'?: string;
    /**
     * 
     * @type {CategoryApplicationResponse}
     * @memberof HandleCategoryApplicationRequest
     */
    'categoryState'?: CategoryApplicationResponse;
}
/**
 * 
 * @export
 * @interface MarketplaceBusinessAnalytics
 */
export interface MarketplaceBusinessAnalytics {
    /**
     * 
     * @type {number}
     * @memberof MarketplaceBusinessAnalytics
     */
    'totalRevenue'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketplaceBusinessAnalytics
     */
    'totalNumberOfOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketplaceBusinessAnalytics
     */
    'totalNumberOfCompletedOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketplaceBusinessAnalytics
     */
    'totalNumberOfInProgressOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketplaceBusinessAnalytics
     */
    'totalNumberOfProducts'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketplaceBusinessAnalytics
     */
    'totalNumberOfCustomers'?: number;
    /**
     * 
     * @type {number}
     * @memberof MarketplaceBusinessAnalytics
     */
    'totalNumberOfBusinesses'?: number;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * An enum that identifies the problem type. 
     * @type {string}
     * @memberof ModelError
     */
    'type': ModelErrorTypeEnum;
    /**
     * A short, summary of the problem type. Written in english and readable for engineers (usually not suited for non technical stakeholders and not localized); example: Service Unavailable 
     * @type {string}
     * @memberof ModelError
     */
    'title'?: string;
    /**
     * The HTTP status code generated by the origin server for this occurrence of the problem. 
     * @type {number}
     * @memberof ModelError
     */
    'status'?: number;
    /**
     * A human readable explanation specific to this occurrence of the problem. 
     * @type {string}
     * @memberof ModelError
     */
    'detail'?: string;
    /**
     * An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced. 
     * @type {string}
     * @memberof ModelError
     */
    'instance'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'error_code'?: ModelErrorErrorCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'trace_id': string;
}

export const ModelErrorTypeEnum = {
    Business: 'BUSINESS',
    Application: 'APPLICATION',
    Routing: 'ROUTING',
    General: 'GENERAL',
    Network: 'NETWORK',
    Security: 'SECURITY',
    Validation: 'VALIDATION',
    Io: 'IO',
    Database: 'DATABASE'
} as const;

export type ModelErrorTypeEnum = typeof ModelErrorTypeEnum[keyof typeof ModelErrorTypeEnum];
export const ModelErrorErrorCodeEnum = {
    GroupNameReserved: 'GROUP_NAME_RESERVED',
    UsernameReserved: 'USERNAME_RESERVED',
    MoveRequiresWriteAccessToAllChildren: 'MOVE_REQUIRES_WRITE_ACCESS_TO_ALL_CHILDREN',
    CreateRequiresReadAccessToAllChildren: 'CREATE_REQUIRES_READ_ACCESS_TO_ALL_CHILDREN',
    ImportAllreadyInProgress: 'IMPORT_ALLREADY_IN_PROGRESS'
} as const;

export type ModelErrorErrorCodeEnum = typeof ModelErrorErrorCodeEnum[keyof typeof ModelErrorErrorCodeEnum];

/**
 * 
 * @export
 * @interface NewSocialUserRequest
 */
export interface NewSocialUserRequest {
    /**
     * 
     * @type {string}
     * @memberof NewSocialUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSocialUserRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSocialUserRequest
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface NewUserRequest
 */
export interface NewUserRequest {
    /**
     * 
     * @type {string}
     * @memberof NewUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof NewUserRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof NewUserRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewUserRequest
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'id'?: string;
    /**
     * 
     * @type {Array<OrderToFulfill>}
     * @memberof Order
     */
    'orderItems'?: Array<OrderToFulfill>;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'placedBy'?: string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof Order
     */
    'orderStatus'?: OrderStatus;
    /**
     * 
     * @type {ShippingDetails}
     * @memberof Order
     */
    'shippingDetails'?: ShippingDetails;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'createdDate'?: string;
}
/**
 * 
 * @export
 * @interface OrderListResponse
 */
export interface OrderListResponse {
    /**
     * 
     * @type {Array<Order>}
     * @memberof OrderListResponse
     */
    'orderList'?: Array<Order>;
    /**
     * 
     * @type {number}
     * @memberof OrderListResponse
     */
    'totalAmountOfPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderListResponse
     */
    'totalAmountOfElements'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrderStatus = {
    AwaitingShipment: 'AWAITING_SHIPMENT',
    ReadyForShipment: 'READY_FOR_SHIPMENT',
    Shipped: 'SHIPPED',
    AwaitingPickup: 'AWAITING_PICKUP',
    Completed: 'COMPLETED'
} as const;

export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];


/**
 * 
 * @export
 * @interface OrderToFulfill
 */
export interface OrderToFulfill {
    /**
     * 
     * @type {string}
     * @memberof OrderToFulfill
     */
    'id'?: string;
    /**
     * 
     * @type {Array<ProductInOrder>}
     * @memberof OrderToFulfill
     */
    'productList'?: Array<ProductInOrder>;
    /**
     * 
     * @type {string}
     * @memberof OrderToFulfill
     */
    'fulfilledBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderToFulfill
     */
    'orderedBy'?: string;
    /**
     * 
     * @type {ShippingDetails}
     * @memberof OrderToFulfill
     */
    'shippingDetails'?: ShippingDetails;
    /**
     * 
     * @type {string}
     * @memberof OrderToFulfill
     */
    'createdDate'?: string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof OrderToFulfill
     */
    'orderStatus'?: OrderStatus;
}
/**
 * 
 * @export
 * @interface OrderToFulfillListResponse
 */
export interface OrderToFulfillListResponse {
    /**
     * 
     * @type {Array<OrderToFulfill>}
     * @memberof OrderToFulfillListResponse
     */
    'orderList'?: Array<OrderToFulfill>;
    /**
     * 
     * @type {number}
     * @memberof OrderToFulfillListResponse
     */
    'totalAmountOfPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderToFulfillListResponse
     */
    'totalAmountOfElements'?: number;
}
/**
 * 
 * @export
 * @interface PatchOrderToFulfillProductStatusRequest
 */
export interface PatchOrderToFulfillProductStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchOrderToFulfillProductStatusRequest
     */
    'orderId': string;
    /**
     * 
     * @type {string}
     * @memberof PatchOrderToFulfillProductStatusRequest
     */
    'productId': string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof PatchOrderToFulfillProductStatusRequest
     */
    'status': OrderStatus;
}
/**
 * 
 * @export
 * @interface PatchOrderToFulfillStatusRequest
 */
export interface PatchOrderToFulfillStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchOrderToFulfillStatusRequest
     */
    'orderId': string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof PatchOrderToFulfillStatusRequest
     */
    'status': OrderStatus;
}
/**
 * 
 * @export
 * @interface PatchProductRequest
 */
export interface PatchProductRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchProductRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PatchProductRequest
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchProductRequest
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchProductRequest
     */
    'categoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchProductRequest
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchProductRequest
     */
    'stockAmount'?: number;
    /**
     * 
     * @type {ProductImage}
     * @memberof PatchProductRequest
     */
    'mainImage'?: ProductImage;
    /**
     * 
     * @type {Array<ProductImage>}
     * @memberof PatchProductRequest
     */
    'additionalImages'?: Array<ProductImage>;
}
/**
 * 
 * @export
 * @interface PrivateBusinessAnalytics
 */
export interface PrivateBusinessAnalytics {
    /**
     * 
     * @type {string}
     * @memberof PrivateBusinessAnalytics
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrivateBusinessAnalytics
     */
    'belongsToBusinessId'?: string;
    /**
     * 
     * @type {number}
     * @memberof PrivateBusinessAnalytics
     */
    'totalNumberOfCompletedOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof PrivateBusinessAnalytics
     */
    'totalNumberOfOrdersToBeCompleted'?: number;
    /**
     * 
     * @type {number}
     * @memberof PrivateBusinessAnalytics
     */
    'totalIncome'?: number;
    /**
     * 
     * @type {number}
     * @memberof PrivateBusinessAnalytics
     */
    'totalSoldAmountProducts'?: number;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'belongsToBusinessId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'categoryId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description'?: string;
    /**
     * 
     * @type {ProductRating}
     * @memberof Product
     */
    'rating'?: ProductRating;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'listedDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'stockAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'totalSold'?: number;
    /**
     * 
     * @type {ProductImage}
     * @memberof Product
     */
    'mainImage'?: ProductImage;
    /**
     * 
     * @type {Array<ProductImage>}
     * @memberof Product
     */
    'additionalImages'?: Array<ProductImage>;
}
/**
 * 
 * @export
 * @interface ProductImage
 */
export interface ProductImage {
    /**
     * File key from AWS S3 bucket
     * @type {string}
     * @memberof ProductImage
     */
    'imageKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductImage
     */
    'imageUrl'?: string;
}
/**
 * 
 * @export
 * @interface ProductInCart
 */
export interface ProductInCart {
    /**
     * 
     * @type {Product}
     * @memberof ProductInCart
     */
    'product'?: Product;
    /**
     * 
     * @type {number}
     * @memberof ProductInCart
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface ProductInOrder
 */
export interface ProductInOrder {
    /**
     * 
     * @type {string}
     * @memberof ProductInOrder
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductInOrder
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductInOrder
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductInOrder
     */
    'description'?: string;
    /**
     * 
     * @type {ProductInOrderMainImage}
     * @memberof ProductInOrder
     */
    'mainImage'?: ProductInOrderMainImage;
    /**
     * 
     * @type {number}
     * @memberof ProductInOrder
     */
    'amount'?: number;
    /**
     * 
     * @type {OrderStatus}
     * @memberof ProductInOrder
     */
    'orderStatus'?: OrderStatus;
}
/**
 * 
 * @export
 * @interface ProductInOrderMainImage
 */
export interface ProductInOrderMainImage {
    /**
     * 
     * @type {string}
     * @memberof ProductInOrderMainImage
     */
    'imageKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductInOrderMainImage
     */
    'imageUrl'?: string;
}
/**
 * 
 * @export
 * @interface ProductListResponse
 */
export interface ProductListResponse {
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductListResponse
     */
    'productList'?: Array<Product>;
    /**
     * 
     * @type {number}
     * @memberof ProductListResponse
     */
    'totalAmountOfPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductListResponse
     */
    'totalAmountOfElements'?: number;
}
/**
 * 
 * @export
 * @interface ProductRating
 */
export interface ProductRating {
    /**
     * 
     * @type {number}
     * @memberof ProductRating
     */
    'fiveStar'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductRating
     */
    'fourStar'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductRating
     */
    'threeStar'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductRating
     */
    'twoStar'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductRating
     */
    'oneStar'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductRating
     */
    'overallRating'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductRating
     */
    'totalRatings'?: number;
}
/**
 * 
 * @export
 * @interface ProductRequest
 */
export interface ProductRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ProductRequest
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof ProductRequest
     */
    'categoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductRequest
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof ProductRequest
     */
    'stockAmount': number;
    /**
     * 
     * @type {ProductImage}
     * @memberof ProductRequest
     */
    'mainImage': ProductImage;
    /**
     * 
     * @type {Array<ProductImage>}
     * @memberof ProductRequest
     */
    'additionalImages'?: Array<ProductImage>;
}
/**
 * 
 * @export
 * @interface PublicBusinessAnalytics
 */
export interface PublicBusinessAnalytics {
    /**
     * 
     * @type {string}
     * @memberof PublicBusinessAnalytics
     */
    'id'?: string;
    /**
     * sold products total
     * @type {number}
     * @memberof PublicBusinessAnalytics
     */
    'soldProductsTotal'?: number;
    /**
     * average product rating
     * @type {number}
     * @memberof PublicBusinessAnalytics
     */
    'averageProductRating'?: number;
    /**
     * business id
     * @type {string}
     * @memberof PublicBusinessAnalytics
     */
    'belongsToBusinessId'?: string;
}
/**
 * 
 * @export
 * @interface RateProductRequest
 */
export interface RateProductRequest {
    /**
     * 
     * @type {string}
     * @memberof RateProductRequest
     */
    'productId'?: string;
    /**
     * 
     * @type {number}
     * @memberof RateProductRequest
     */
    'rating'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Role = {
    BusinessOwner: 'BUSINESS_OWNER',
    Customer: 'CUSTOMER',
    Admin: 'ADMIN'
} as const;

export type Role = typeof Role[keyof typeof Role];


/**
 * 
 * @export
 * @interface ShippingDetails
 */
export interface ShippingDetails {
    /**
     * 
     * @type {string}
     * @memberof ShippingDetails
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingDetails
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingDetails
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingDetails
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingDetails
     */
    'postalCode'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SortProductBy = {
    PriceAsc: 'PRICE_ASC',
    PriceDsc: 'PRICE_DSC',
    NameAsc: 'NAME_ASC',
    NameDsc: 'NAME_DSC',
    TotalSoldAsc: 'TOTAL_SOLD_ASC',
    TotalSoldDsc: 'TOTAL_SOLD_DSC',
    RatingAsc: 'RATING_ASC',
    RatingDsc: 'RATING_DSC'
} as const;

export type SortProductBy = typeof SortProductBy[keyof typeof SortProductBy];


/**
 * 
 * @export
 * @interface SupportThread
 */
export interface SupportThread {
    /**
     * 
     * @type {string}
     * @memberof SupportThread
     */
    'supportThreadId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupportThread
     */
    'threadAuthorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupportThread
     */
    'threadAuthorEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof SupportThread
     */
    'threadTopic'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SupportThread
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SupportThread
     */
    'createdDate'?: string;
}
/**
 * 
 * @export
 * @interface SupportThreadPageResponse
 */
export interface SupportThreadPageResponse {
    /**
     * 
     * @type {Array<SupportThread>}
     * @memberof SupportThreadPageResponse
     */
    'SupportThreadPageList': Array<SupportThread>;
    /**
     * 
     * @type {number}
     * @memberof SupportThreadPageResponse
     */
    'totalAmountOfPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof SupportThreadPageResponse
     */
    'totalAmountOfElements'?: number;
}
/**
 * 
 * @export
 * @interface ThreadReply
 */
export interface ThreadReply {
    /**
     * 
     * @type {string}
     * @memberof ThreadReply
     */
    'threadReplyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThreadReply
     */
    'parentThreadId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThreadReply
     */
    'text'?: string;
    /**
     * 
     * @type {ThreadReplyAuthor}
     * @memberof ThreadReply
     */
    'author'?: ThreadReplyAuthor;
    /**
     * 
     * @type {string}
     * @memberof ThreadReply
     */
    'createdDate'?: string;
}
/**
 * 
 * @export
 * @interface ThreadReplyAuthor
 */
export interface ThreadReplyAuthor {
    /**
     * 
     * @type {string}
     * @memberof ThreadReplyAuthor
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThreadReplyAuthor
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ThreadReplyAuthor
     */
    'isCreatorOfTheThread'?: boolean;
}
/**
 * 
 * @export
 * @interface ThreadReplyPageResponse
 */
export interface ThreadReplyPageResponse {
    /**
     * 
     * @type {Array<ThreadReply>}
     * @memberof ThreadReplyPageResponse
     */
    'ThreadReplyPageList'?: Array<ThreadReply>;
    /**
     * 
     * @type {number}
     * @memberof ThreadReplyPageResponse
     */
    'totalAmountOfPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof ThreadReplyPageResponse
     */
    'totalAmountOfElements'?: number;
}
/**
 * 
 * @export
 * @interface UpdateBusinessApplicationRequest
 */
export interface UpdateBusinessApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessApplicationRequest
     */
    'id': string;
    /**
     * 
     * @type {BusinessDescription}
     * @memberof UpdateBusinessApplicationRequest
     */
    'businessDescription': BusinessDescription;
    /**
     * 
     * @type {BusinessPaymentDetails}
     * @memberof UpdateBusinessApplicationRequest
     */
    'businessPaymentDetails': BusinessPaymentDetails;
    /**
     * 
     * @type {BusinessLegalDocuments}
     * @memberof UpdateBusinessApplicationRequest
     */
    'businessLegalDocuments': BusinessLegalDocuments;
    /**
     * 
     * @type {BusinessContacts}
     * @memberof UpdateBusinessApplicationRequest
     */
    'businessContacts'?: BusinessContacts;
    /**
     * 
     * @type {BusinessLogo}
     * @memberof UpdateBusinessApplicationRequest
     */
    'businessLogo'?: BusinessLogo;
}
/**
 * 
 * @export
 * @interface UpdateBusinessRequest
 */
export interface UpdateBusinessRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessRequest
     */
    'id'?: string;
    /**
     * 
     * @type {BusinessDescription}
     * @memberof UpdateBusinessRequest
     */
    'businessDescription': BusinessDescription;
    /**
     * 
     * @type {BusinessPaymentDetails}
     * @memberof UpdateBusinessRequest
     */
    'businessPaymentDetails': BusinessPaymentDetails;
    /**
     * 
     * @type {BusinessLegalDocuments}
     * @memberof UpdateBusinessRequest
     */
    'businessLegalDocuments': BusinessLegalDocuments;
    /**
     * 
     * @type {BusinessContacts}
     * @memberof UpdateBusinessRequest
     */
    'businessContacts'?: BusinessContacts;
    /**
     * 
     * @type {BusinessLogo}
     * @memberof UpdateBusinessRequest
     */
    'businessLogo'?: BusinessLogo;
}
/**
 * 
 * @export
 * @interface UpdateBusinessReviewRequest
 */
export interface UpdateBusinessReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessReviewRequest
     */
    'id'?: string;
    /**
     * 
     * @type {BusinessReviewState}
     * @memberof UpdateBusinessReviewRequest
     */
    'businessReviewState'?: BusinessReviewState;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessReviewRequest
     */
    'businessReviewDescription'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCategoryRequest
 */
export interface UpdateCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCategoryRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCategoryRequest
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProductInCartRequest
 */
export interface UpdateProductInCartRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateProductInCartRequest
     */
    'productId'?: string;
    /**
     * The amount of the product to add to the cart.
     * @type {number}
     * @memberof UpdateProductInCartRequest
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface UserBusinessInfoResponse
 */
export interface UserBusinessInfoResponse {
    /**
     * 
     * @type {Business}
     * @memberof UserBusinessInfoResponse
     */
    'business'?: Business;
    /**
     * 
     * @type {BusinessApplication}
     * @memberof UserBusinessInfoResponse
     */
    'businessApplication'?: BusinessApplication;
    /**
     * 
     * @type {BusinessApplicationReview}
     * @memberof UserBusinessInfoResponse
     */
    'businessApplicationReview'?: BusinessApplicationReview;
}
/**
 * 
 * @export
 * @interface UserProductRating
 */
export interface UserProductRating {
    /**
     * 
     * @type {string}
     * @memberof UserProductRating
     */
    'ratedBy'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserProductRating
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserProductRating
     */
    'ratedProductId'?: string;
}
/**
 * 
 * @export
 * @interface Wishlist
 */
export interface Wishlist {
    /**
     * 
     * @type {string}
     * @memberof Wishlist
     */
    'id'?: string;
    /**
     * 
     * @type {Array<Product>}
     * @memberof Wishlist
     */
    'wishlist'?: Array<Product>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddRemoveProductToWishlistRequest} [addRemoveProductToWishlistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductToWishlist: async (addRemoveProductToWishlistRequest?: AddRemoveProductToWishlistRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-wishlist/add-product-to-wishlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addRemoveProductToWishlistRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close support thread
         * @param {CloseSupportThreadRequest} [closeSupportThreadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeSupportThread: async (closeSupportThreadRequest?: CloseSupportThreadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/support-thread/close-support-thread`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(closeSupportThreadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new business application
         * @param {CreateBusinessApplicationRequest} [createBusinessApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessApplication: async (createBusinessApplicationRequest?: CreateBusinessApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/business-application/create-business-application`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBusinessApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new business application review
         * @param {CreateBusinessReviewRequest} [createBusinessReviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessApplicationReview: async (createBusinessReviewRequest?: CreateBusinessReviewRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/business-review/create-review`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBusinessReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new category application
         * @param {CreateCategoryApplicationRequest} [createCategoryApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategoryApplication: async (createCategoryApplicationRequest?: CreateCategoryApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category/create-category-application`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCategoryApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/checkout/create-checkout-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new comment to the post
         * @param {CreateNewCommentRequest} [createNewCommentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewComment: async (createNewCommentRequest?: CreateNewCommentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/comment/create-new-comment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNewCommentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new reply to the comment
         * @param {CreateNewCommentReplyRequest} [createNewCommentReplyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewCommentReply: async (createNewCommentReplyRequest?: CreateNewCommentReplyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/comment/create-new-comment-reply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNewCommentReplyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProductRequest} [productRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (productRequest?: ProductRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/create-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user, in case it is already present in the keycloak user database. Endpoint should be called when a user logs in with social identity providers(google,facebook)
         * @param {NewSocialUserRequest} [newSocialUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSocialUser: async (newSocialUserRequest?: NewSocialUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/create-social-customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newSocialUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create support thread
         * @param {CreateNewSupportThreadRequest} [createNewSupportThreadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupportThread: async (createNewSupportThreadRequest?: CreateNewSupportThreadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/support-thread/create-support-thread`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNewSupportThreadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create thread reply for given thread
         * @param {CreateNewThreadReplyRequest} [createNewThreadReplyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThreadReplyForGivenThread: async (createNewThreadReplyRequest?: CreateNewThreadReplyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/support-thread-reply/create-thread-reply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNewThreadReplyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new user
         * @param {NewUserRequest} [newUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (newUserRequest?: NewUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/create-customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete category by id for admin
         * @param {string} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryById: async (categoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteCategoryById', 'categoryId', categoryId)
            const localVarPath = `/category/delete-category-by-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete product by id for admin/business owner
         * @param {string} productId productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductById: async (productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('deleteProductById', 'productId', productId)
            const localVarPath = `/products/delete-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete current users cart. A empty cart will be recreated and attached to the user
         * @param {DeleteProductInCartRequest} [deleteProductInCartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductInCart: async (deleteProductInCartRequest?: DeleteProductInCartRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-cart/delete-product-in-cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteProductInCartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download legal document
         * @param {string} fileKeyBase64Encoded AWS S3 File key encoded in base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLegalDocument: async (fileKeyBase64Encoded: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileKeyBase64Encoded' is not null or undefined
            assertParamExists('downloadLegalDocument', 'fileKeyBase64Encoded', fileKeyBase64Encoded)
            const localVarPath = `/business-application/download-legal-document/{fileKeyBase64Encoded}`
                .replace(`{${"fileKeyBase64Encoded"}}`, encodeURIComponent(String(fileKeyBase64Encoded)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get active support thread for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveSupportThreadForCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/support-thread/get-actvie-support-thread-for-current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get active support thread page
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveSupportThreadPage: async (pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getActiveSupportThreadPage', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getActiveSupportThreadPage', 'pageNumber', pageNumber)
            const localVarPath = `/support-thread/get-active-support-thread-page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get archived support thread page
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArchivedSupportThreadPage: async (pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getArchivedSupportThreadPage', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getArchivedSupportThreadPage', 'pageNumber', pageNumber)
            const localVarPath = `/support-thread/get-archieved-support-thread-page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get business application by id
         * @param {string} businessApplicationId id of business application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessApplicationById: async (businessApplicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessApplicationId' is not null or undefined
            assertParamExists('getBusinessApplicationById', 'businessApplicationId', businessApplicationId)
            const localVarPath = `/business-application/get-application-by-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (businessApplicationId !== undefined) {
                localVarQueryParameter['businessApplicationId'] = businessApplicationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get business application list
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessApplicationList: async (pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getBusinessApplicationList', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getBusinessApplicationList', 'pageNumber', pageNumber)
            const localVarPath = `/business-application/get-application-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get business by id
         * @param {string} businessId business id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessById: async (businessId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessById', 'businessId', businessId)
            const localVarPath = `/business/get-business-by-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get business for public by id
         * @param {string} businessId business id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessForPublicById: async (businessId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessForPublicById', 'businessId', businessId)
            const localVarPath = `/business/get-business-for-public-by-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get business list for admin
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessListForAdmin: async (pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getBusinessListForAdmin', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getBusinessListForAdmin', 'pageNumber', pageNumber)
            const localVarPath = `/business/get-business-list-for-admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get business list
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessListForPublic: async (pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getBusinessListForPublic', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getBusinessListForPublic', 'pageNumber', pageNumber)
            const localVarPath = `/business/get-business-list-for-public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCart: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-cart/get-cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get category applications list for admin
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryApplicationList: async (pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getCategoryApplicationList', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getCategoryApplicationList', 'pageNumber', pageNumber)
            const localVarPath = `/category/get-category-application-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get category applications list for admin
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryList: async (pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getCategoryList', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getCategoryList', 'pageNumber', pageNumber)
            const localVarPath = `/category/get-category-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get comment tree list by product id
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {string} productId product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentTreeListForProduct: async (pageSize: number, pageNumber: number, productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getCommentTreeListForProduct', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getCommentTreeListForProduct', 'pageNumber', pageNumber)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getCommentTreeListForProduct', 'productId', productId)
            const localVarPath = `/comment/get-comments-by-product-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get current authenticated user business information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserBusinessInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/get-current-user-business-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get current authenticated user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/get-current-user-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get marketplace analytics
         * @summary Get marketplace analytics, accessible only by admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketplaceAnalytics: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/business-analytics/get-marketplace-analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get customers order list
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {OrderStatus} [filterBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderList: async (pageSize: number, pageNumber: number, filterBy?: OrderStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getOrderList', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getOrderList', 'pageNumber', pageNumber)
            const localVarPath = `/user-order/get-order-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (filterBy !== undefined) {
                localVarQueryParameter['filterBy'] = filterBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order to fulfill for business owner
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {OrderStatus} [filterBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderToFulfillList: async (pageSize: number, pageNumber: number, filterBy?: OrderStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getOrderToFulfillList', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getOrderToFulfillList', 'pageNumber', pageNumber)
            const localVarPath = `/user-order/get-order-to-fulfill-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (filterBy !== undefined) {
                localVarQueryParameter['filterBy'] = filterBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get private business analytics
         * @summary Get private business analytics, accessible only by business owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivateBusinessAnalytics: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/business-analytics/get-private-business-analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Product by id
         * @param {string} productId Product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductById: async (productId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductById', 'productId', productId)
            const localVarPath = `/products/get-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product by business
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {string} businessId Business Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsByBusiness: async (pageSize: number, pageNumber: number, businessId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getProductsByBusiness', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getProductsByBusiness', 'pageNumber', pageNumber)
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getProductsByBusiness', 'businessId', businessId)
            const localVarPath = `/products/get-products-by-business`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get public business analytics
         * @summary Get public business analytics
         * @param {string} businessId business id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicBusinessAnalytics: async (businessId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getPublicBusinessAnalytics', 'businessId', businessId)
            const localVarPath = `/business-analytics/get-public-business-analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (businessId !== undefined) {
                localVarQueryParameter['businessId'] = businessId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get review by id
         * @param {string} businessReviewId review id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewById: async (businessReviewId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessReviewId' is not null or undefined
            assertParamExists('getReviewById', 'businessReviewId', businessReviewId)
            const localVarPath = `/business-review/get-review-by-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (businessReviewId !== undefined) {
                localVarQueryParameter['businessReviewId'] = businessReviewId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get thread replies page for given thread
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {string} threadId support thread id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadRepliesPage: async (pageSize: number, pageNumber: number, threadId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getThreadRepliesPage', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('getThreadRepliesPage', 'pageNumber', pageNumber)
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('getThreadRepliesPage', 'threadId', threadId)
            const localVarPath = `/support-thread-reply/get-thread-replies-page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (threadId !== undefined) {
                localVarQueryParameter['threadId'] = threadId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user wishlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWishlist: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-wishlist/get-user-wishlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * handle new category application
         * @param {HandleCategoryApplicationRequest} [handleCategoryApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNewCategoryApplication: async (handleCategoryApplicationRequest?: HandleCategoryApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category/handle-category-application-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(handleCategoryApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates order to fulfill product status, in case all products have the same status the order status will be updated
         * @param {PatchOrderToFulfillProductStatusRequest} [patchOrderToFulfillProductStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrderToFulfillProductStatus: async (patchOrderToFulfillProductStatusRequest?: PatchOrderToFulfillProductStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-order/update-order-to-fulfill-product-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOrderToFulfillProductStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates order to fulfill and all its related products status
         * @param {PatchOrderToFulfillStatusRequest} [patchOrderToFulfillStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrderToFulfillStatus: async (patchOrderToFulfillStatusRequest?: PatchOrderToFulfillStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-order/update-order-to-fulfill-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOrderToFulfillStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatchProductRequest} [patchProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProduct: async (patchProductRequest?: PatchProductRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/patch-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post product to users cart
         * @param {AddProductToCartRequest} [addProductToCartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductInCart: async (addProductToCartRequest?: AddProductToCartRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-cart/post-product-in-cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addProductToCartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rate a product, product should be in the order with status completed
         * @param {RateProductRequest} [rateProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateProduct: async (rateProductRequest?: RateProductRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/rate-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rateProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete current users cart. A empty cart will be recreated and attached to the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recycleCart: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-cart/recycle-cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddRemoveProductToWishlistRequest} [addRemoveProductToWishlistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProductFromWishlist: async (addRemoveProductToWishlistRequest?: AddRemoveProductToWishlistRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-wishlist/remove-product-to-wishlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addRemoveProductToWishlistRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Product by text. The searched will be performed based on product name and description
         * @param {string} text Product name and description
         * @param {number} [limitResults] Limit the amount of returned results. Defaults to 5
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAutocompleteProduct: async (text: string, limitResults?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'text' is not null or undefined
            assertParamExists('searchAutocompleteProduct', 'text', text)
            const localVarPath = `/products/search-autocomplete-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (limitResults !== undefined) {
                localVarQueryParameter['limitResults'] = limitResults;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search business
         * @param {string} text Product name or description
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBusiness: async (text: string, pageSize: number, pageNumber: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'text' is not null or undefined
            assertParamExists('searchBusiness', 'text', text)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('searchBusiness', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('searchBusiness', 'pageNumber', pageNumber)
            const localVarPath = `/business/search-business`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search Product by name or description.
         * @param {string} text Product name or description
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {SortProductBy} [sortBy] 
         * @param {FilterProductBy} [filterBy] Filter product by category or stock availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProduct: async (text: string, pageSize: number, pageNumber: number, sortBy?: SortProductBy, filterBy?: FilterProductBy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'text' is not null or undefined
            assertParamExists('searchProduct', 'text', text)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('searchProduct', 'pageSize', pageSize)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('searchProduct', 'pageNumber', pageNumber)
            const localVarPath = `/products/search-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (filterBy !== undefined) {
                localVarQueryParameter['filterBy'] = filterBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update business
         * @param {UpdateBusinessRequest} [updateBusinessRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusiness: async (updateBusinessRequest?: UpdateBusinessRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/business/update-business`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBusinessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update business application
         * @param {UpdateBusinessApplicationRequest} [updateBusinessApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessApplication: async (updateBusinessApplicationRequest?: UpdateBusinessApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/business-application/update-business-application`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBusinessApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update business application review
         * @param {UpdateBusinessReviewRequest} [updateBusinessReviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessApplicationReview: async (updateBusinessReviewRequest?: UpdateBusinessReviewRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/business-review/update-review`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBusinessReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update category
         * @param {UpdateCategoryRequest} [updateCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (updateCategoryRequest?: UpdateCategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category/update-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch products in cart
         * @param {UpdateProductInCartRequest} [updateProductInCartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductInCart: async (updateProductInCartRequest?: UpdateProductInCartRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-cart/update-product-in-cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductInCartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload company logo for the business application
         * @param {File} [logoFile] Logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCompanyLogo: async (logoFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/business-application/upload-logo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (logoFile !== undefined) { 
                localVarFormParams.append('logoFile', logoFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload legal documents for the business application
         * @param {File} registrationCertificate Current company status from the Trade Register or Registry Agency
         * @param {File} bankStatement The document is generated by the bank. It is accepted bank statement or screenshot from your online banking, with the name of the company and the IBAN of the company account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLegalDocuments: async (registrationCertificate: File, bankStatement: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registrationCertificate' is not null or undefined
            assertParamExists('uploadLegalDocuments', 'registrationCertificate', registrationCertificate)
            // verify required parameter 'bankStatement' is not null or undefined
            assertParamExists('uploadLegalDocuments', 'bankStatement', bankStatement)
            const localVarPath = `/business-application/upload-legal-documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (registrationCertificate !== undefined) { 
                localVarFormParams.append('registrationCertificate', registrationCertificate as any);
            }
    
            if (bankStatement !== undefined) { 
                localVarFormParams.append('bankStatement', bankStatement as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProductImage: async (image: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            assertParamExists('uploadProductImage', 'image', image)
            const localVarPath = `/products/upload-product-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddRemoveProductToWishlistRequest} [addRemoveProductToWishlistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProductToWishlist(addRemoveProductToWishlistRequest?: AddRemoveProductToWishlistRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wishlist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProductToWishlist(addRemoveProductToWishlistRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Close support thread
         * @param {CloseSupportThreadRequest} [closeSupportThreadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeSupportThread(closeSupportThreadRequest?: CloseSupportThreadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportThread>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeSupportThread(closeSupportThreadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new business application
         * @param {CreateBusinessApplicationRequest} [createBusinessApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBusinessApplication(createBusinessApplicationRequest?: CreateBusinessApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBusinessApplication(createBusinessApplicationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new business application review
         * @param {CreateBusinessReviewRequest} [createBusinessReviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBusinessApplicationReview(createBusinessReviewRequest?: CreateBusinessReviewRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessApplicationReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBusinessApplicationReview(createBusinessReviewRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new category application
         * @param {CreateCategoryApplicationRequest} [createCategoryApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategoryApplication(createCategoryApplicationRequest?: CreateCategoryApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCategoryApplication(createCategoryApplicationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSession(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCheckoutSession201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckoutSession(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new comment to the post
         * @param {CreateNewCommentRequest} [createNewCommentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewComment(createNewCommentRequest?: CreateNewCommentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewComment(createNewCommentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new reply to the comment
         * @param {CreateNewCommentReplyRequest} [createNewCommentReplyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewCommentReply(createNewCommentReplyRequest?: CreateNewCommentReplyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewCommentReply(createNewCommentReplyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ProductRequest} [productRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(productRequest?: ProductRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(productRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new user, in case it is already present in the keycloak user database. Endpoint should be called when a user logs in with social identity providers(google,facebook)
         * @param {NewSocialUserRequest} [newSocialUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSocialUser(newSocialUserRequest?: NewSocialUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSocialUser(newSocialUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create support thread
         * @param {CreateNewSupportThreadRequest} [createNewSupportThreadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSupportThread(createNewSupportThreadRequest?: CreateNewSupportThreadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportThread>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSupportThread(createNewSupportThreadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create thread reply for given thread
         * @param {CreateNewThreadReplyRequest} [createNewThreadReplyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createThreadReplyForGivenThread(createNewThreadReplyRequest?: CreateNewThreadReplyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createThreadReplyForGivenThread(createNewThreadReplyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new user
         * @param {NewUserRequest} [newUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(newUserRequest?: NewUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(newUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete category by id for admin
         * @param {string} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategoryById(categoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategoryById(categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete product by id for admin/business owner
         * @param {string} productId productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductById(productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductById(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete current users cart. A empty cart will be recreated and attached to the user
         * @param {DeleteProductInCartRequest} [deleteProductInCartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductInCart(deleteProductInCartRequest?: DeleteProductInCartRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductInCart(deleteProductInCartRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download legal document
         * @param {string} fileKeyBase64Encoded AWS S3 File key encoded in base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadLegalDocument(fileKeyBase64Encoded: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadLegalDocument(fileKeyBase64Encoded, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get active support thread for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveSupportThreadForCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportThread>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveSupportThreadForCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get active support thread page
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveSupportThreadPage(pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportThreadPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveSupportThreadPage(pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get archived support thread page
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArchivedSupportThreadPage(pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportThreadPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArchivedSupportThreadPage(pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get business application by id
         * @param {string} businessApplicationId id of business application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessApplicationById(businessApplicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessApplicationById(businessApplicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get business application list
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessApplicationList(pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessApplicationListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessApplicationList(pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get business by id
         * @param {string} businessId business id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessById(businessId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Business>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessById(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get business for public by id
         * @param {string} businessId business id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessForPublicById(businessId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessForPublicResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessForPublicById(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get business list for admin
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessListForAdmin(pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessForAdminListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessListForAdmin(pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get business list
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessListForPublic(pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessForPublicListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessListForPublic(pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current user cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCart(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCart(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get category applications list for admin
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryApplicationList(pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryApplicationListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryApplicationList(pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get category applications list for admin
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryList(pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryList(pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get comment tree list by product id
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {string} productId product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommentTreeListForProduct(pageSize: number, pageNumber: number, productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentTreeListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommentTreeListForProduct(pageSize, pageNumber, productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get current authenticated user business information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserBusinessInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBusinessInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserBusinessInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get current authenticated user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get marketplace analytics
         * @summary Get marketplace analytics, accessible only by admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketplaceAnalytics(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketplaceBusinessAnalytics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketplaceAnalytics(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get customers order list
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {OrderStatus} [filterBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderList(pageSize: number, pageNumber: number, filterBy?: OrderStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderList(pageSize, pageNumber, filterBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get order to fulfill for business owner
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {OrderStatus} [filterBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderToFulfillList(pageSize: number, pageNumber: number, filterBy?: OrderStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderToFulfillListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderToFulfillList(pageSize, pageNumber, filterBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get private business analytics
         * @summary Get private business analytics, accessible only by business owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrivateBusinessAnalytics(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateBusinessAnalytics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrivateBusinessAnalytics(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Product by id
         * @param {string} productId Product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductById(productId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductById(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get product by business
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {string} businessId Business Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsByBusiness(pageSize: number, pageNumber: number, businessId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductsByBusiness(pageSize, pageNumber, businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get public business analytics
         * @summary Get public business analytics
         * @param {string} businessId business id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicBusinessAnalytics(businessId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicBusinessAnalytics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicBusinessAnalytics(businessId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get review by id
         * @param {string} businessReviewId review id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewById(businessReviewId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessApplicationReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewById(businessReviewId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get thread replies page for given thread
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {string} threadId support thread id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThreadRepliesPage(pageSize: number, pageNumber: number, threadId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadReplyPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThreadRepliesPage(pageSize, pageNumber, threadId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current user wishlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWishlist(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wishlist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWishlist(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * handle new category application
         * @param {HandleCategoryApplicationRequest} [handleCategoryApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleNewCategoryApplication(handleCategoryApplicationRequest?: HandleCategoryApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleNewCategoryApplication(handleCategoryApplicationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates order to fulfill product status, in case all products have the same status the order status will be updated
         * @param {PatchOrderToFulfillProductStatusRequest} [patchOrderToFulfillProductStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOrderToFulfillProductStatus(patchOrderToFulfillProductStatusRequest?: PatchOrderToFulfillProductStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderToFulfill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOrderToFulfillProductStatus(patchOrderToFulfillProductStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates order to fulfill and all its related products status
         * @param {PatchOrderToFulfillStatusRequest} [patchOrderToFulfillStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOrderToFulfillStatus(patchOrderToFulfillStatusRequest?: PatchOrderToFulfillStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderToFulfill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOrderToFulfillStatus(patchOrderToFulfillStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PatchProductRequest} [patchProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchProduct(patchProductRequest?: PatchProductRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchProduct(patchProductRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Post product to users cart
         * @param {AddProductToCartRequest} [addProductToCartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductInCart(addProductToCartRequest?: AddProductToCartRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProductInCart(addProductToCartRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rate a product, product should be in the order with status completed
         * @param {RateProductRequest} [rateProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rateProduct(rateProductRequest?: RateProductRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rateProduct(rateProductRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete current users cart. A empty cart will be recreated and attached to the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recycleCart(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recycleCart(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AddRemoveProductToWishlistRequest} [addRemoveProductToWishlistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeProductFromWishlist(addRemoveProductToWishlistRequest?: AddRemoveProductToWishlistRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wishlist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeProductFromWishlist(addRemoveProductToWishlistRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Product by text. The searched will be performed based on product name and description
         * @param {string} text Product name and description
         * @param {number} [limitResults] Limit the amount of returned results. Defaults to 5
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAutocompleteProduct(text: string, limitResults?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteProductResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAutocompleteProduct(text, limitResults, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search business
         * @param {string} text Product name or description
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchBusiness(text: string, pageSize: number, pageNumber: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessForPublicListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchBusiness(text, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search Product by name or description.
         * @param {string} text Product name or description
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {SortProductBy} [sortBy] 
         * @param {FilterProductBy} [filterBy] Filter product by category or stock availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchProduct(text: string, pageSize: number, pageNumber: number, sortBy?: SortProductBy, filterBy?: FilterProductBy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchProduct(text, pageSize, pageNumber, sortBy, filterBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update business
         * @param {UpdateBusinessRequest} [updateBusinessRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBusiness(updateBusinessRequest?: UpdateBusinessRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Business>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBusiness(updateBusinessRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update business application
         * @param {UpdateBusinessApplicationRequest} [updateBusinessApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBusinessApplication(updateBusinessApplicationRequest?: UpdateBusinessApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBusinessApplication(updateBusinessApplicationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update business application review
         * @param {UpdateBusinessReviewRequest} [updateBusinessReviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBusinessApplicationReview(updateBusinessReviewRequest?: UpdateBusinessReviewRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessApplicationReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBusinessApplicationReview(updateBusinessReviewRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update category
         * @param {UpdateCategoryRequest} [updateCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(updateCategoryRequest?: UpdateCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(updateCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Patch products in cart
         * @param {UpdateProductInCartRequest} [updateProductInCartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductInCart(updateProductInCartRequest?: UpdateProductInCartRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductInCart(updateProductInCartRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload company logo for the business application
         * @param {File} [logoFile] Logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCompanyLogo(logoFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessLogo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCompanyLogo(logoFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload legal documents for the business application
         * @param {File} registrationCertificate Current company status from the Trade Register or Registry Agency
         * @param {File} bankStatement The document is generated by the bank. It is accepted bank statement or screenshot from your online banking, with the name of the company and the IBAN of the company account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadLegalDocuments(registrationCertificate: File, bankStatement: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessLegalDocuments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadLegalDocuments(registrationCertificate, bankStatement, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProductImage(image: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProductImage(image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {AddRemoveProductToWishlistRequest} [addRemoveProductToWishlistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductToWishlist(addRemoveProductToWishlistRequest?: AddRemoveProductToWishlistRequest, options?: any): AxiosPromise<Wishlist> {
            return localVarFp.addProductToWishlist(addRemoveProductToWishlistRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Close support thread
         * @param {CloseSupportThreadRequest} [closeSupportThreadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeSupportThread(closeSupportThreadRequest?: CloseSupportThreadRequest, options?: any): AxiosPromise<SupportThread> {
            return localVarFp.closeSupportThread(closeSupportThreadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new business application
         * @param {CreateBusinessApplicationRequest} [createBusinessApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessApplication(createBusinessApplicationRequest?: CreateBusinessApplicationRequest, options?: any): AxiosPromise<BusinessApplication> {
            return localVarFp.createBusinessApplication(createBusinessApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new business application review
         * @param {CreateBusinessReviewRequest} [createBusinessReviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessApplicationReview(createBusinessReviewRequest?: CreateBusinessReviewRequest, options?: any): AxiosPromise<BusinessApplicationReview> {
            return localVarFp.createBusinessApplicationReview(createBusinessReviewRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new category application
         * @param {CreateCategoryApplicationRequest} [createCategoryApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategoryApplication(createCategoryApplicationRequest?: CreateCategoryApplicationRequest, options?: any): AxiosPromise<CategoryApplication> {
            return localVarFp.createCategoryApplication(createCategoryApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession(options?: any): AxiosPromise<CreateCheckoutSession201Response> {
            return localVarFp.createCheckoutSession(options).then((request) => request(axios, basePath));
        },
        /**
         * Create new comment to the post
         * @param {CreateNewCommentRequest} [createNewCommentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewComment(createNewCommentRequest?: CreateNewCommentRequest, options?: any): AxiosPromise<Comment> {
            return localVarFp.createNewComment(createNewCommentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new reply to the comment
         * @param {CreateNewCommentReplyRequest} [createNewCommentReplyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewCommentReply(createNewCommentReplyRequest?: CreateNewCommentReplyRequest, options?: any): AxiosPromise<Comment> {
            return localVarFp.createNewCommentReply(createNewCommentReplyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProductRequest} [productRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(productRequest?: ProductRequest, options?: any): AxiosPromise<Product> {
            return localVarFp.createProduct(productRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user, in case it is already present in the keycloak user database. Endpoint should be called when a user logs in with social identity providers(google,facebook)
         * @param {NewSocialUserRequest} [newSocialUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSocialUser(newSocialUserRequest?: NewSocialUserRequest, options?: any): AxiosPromise<AppUser> {
            return localVarFp.createSocialUser(newSocialUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create support thread
         * @param {CreateNewSupportThreadRequest} [createNewSupportThreadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupportThread(createNewSupportThreadRequest?: CreateNewSupportThreadRequest, options?: any): AxiosPromise<SupportThread> {
            return localVarFp.createSupportThread(createNewSupportThreadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create thread reply for given thread
         * @param {CreateNewThreadReplyRequest} [createNewThreadReplyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThreadReplyForGivenThread(createNewThreadReplyRequest?: CreateNewThreadReplyRequest, options?: any): AxiosPromise<ThreadReply> {
            return localVarFp.createThreadReplyForGivenThread(createNewThreadReplyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new user
         * @param {NewUserRequest} [newUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(newUserRequest?: NewUserRequest, options?: any): AxiosPromise<AppUser> {
            return localVarFp.createUser(newUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * delete category by id for admin
         * @param {string} categoryId categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryById(categoryId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteCategoryById(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete product by id for admin/business owner
         * @param {string} productId productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductById(productId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteProductById(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete current users cart. A empty cart will be recreated and attached to the user
         * @param {DeleteProductInCartRequest} [deleteProductInCartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductInCart(deleteProductInCartRequest?: DeleteProductInCartRequest, options?: any): AxiosPromise<Cart> {
            return localVarFp.deleteProductInCart(deleteProductInCartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Download legal document
         * @param {string} fileKeyBase64Encoded AWS S3 File key encoded in base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLegalDocument(fileKeyBase64Encoded: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadLegalDocument(fileKeyBase64Encoded, options).then((request) => request(axios, basePath));
        },
        /**
         * get active support thread for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveSupportThreadForCurrentUser(options?: any): AxiosPromise<SupportThread> {
            return localVarFp.getActiveSupportThreadForCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * get active support thread page
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveSupportThreadPage(pageSize: number, pageNumber: number, options?: any): AxiosPromise<SupportThreadPageResponse> {
            return localVarFp.getActiveSupportThreadPage(pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * get archived support thread page
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArchivedSupportThreadPage(pageSize: number, pageNumber: number, options?: any): AxiosPromise<SupportThreadPageResponse> {
            return localVarFp.getArchivedSupportThreadPage(pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * get business application by id
         * @param {string} businessApplicationId id of business application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessApplicationById(businessApplicationId: string, options?: any): AxiosPromise<BusinessApplication> {
            return localVarFp.getBusinessApplicationById(businessApplicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * get business application list
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessApplicationList(pageSize: number, pageNumber: number, options?: any): AxiosPromise<BusinessApplicationListResponse> {
            return localVarFp.getBusinessApplicationList(pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * get business by id
         * @param {string} businessId business id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessById(businessId: string, options?: any): AxiosPromise<Business> {
            return localVarFp.getBusinessById(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * get business for public by id
         * @param {string} businessId business id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessForPublicById(businessId: string, options?: any): AxiosPromise<BusinessForPublicResponse> {
            return localVarFp.getBusinessForPublicById(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * get business list for admin
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessListForAdmin(pageSize: number, pageNumber: number, options?: any): AxiosPromise<BusinessForAdminListResponse> {
            return localVarFp.getBusinessListForAdmin(pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * get business list
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessListForPublic(pageSize: number, pageNumber: number, options?: any): AxiosPromise<BusinessForPublicListResponse> {
            return localVarFp.getBusinessListForPublic(pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCart(options?: any): AxiosPromise<Cart> {
            return localVarFp.getCart(options).then((request) => request(axios, basePath));
        },
        /**
         * get category applications list for admin
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryApplicationList(pageSize: number, pageNumber: number, options?: any): AxiosPromise<CategoryApplicationListResponse> {
            return localVarFp.getCategoryApplicationList(pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * get category applications list for admin
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryList(pageSize: number, pageNumber: number, options?: any): AxiosPromise<CategoryListResponse> {
            return localVarFp.getCategoryList(pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * get comment tree list by product id
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {string} productId product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentTreeListForProduct(pageSize: number, pageNumber: number, productId: string, options?: any): AxiosPromise<CommentTreeListResponse> {
            return localVarFp.getCommentTreeListForProduct(pageSize, pageNumber, productId, options).then((request) => request(axios, basePath));
        },
        /**
         * get current authenticated user business information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserBusinessInfo(options?: any): AxiosPromise<UserBusinessInfoResponse> {
            return localVarFp.getCurrentUserBusinessInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * get current authenticated user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfo(options?: any): AxiosPromise<AppUser> {
            return localVarFp.getCurrentUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Get marketplace analytics
         * @summary Get marketplace analytics, accessible only by admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketplaceAnalytics(options?: any): AxiosPromise<MarketplaceBusinessAnalytics> {
            return localVarFp.getMarketplaceAnalytics(options).then((request) => request(axios, basePath));
        },
        /**
         * Get customers order list
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {OrderStatus} [filterBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderList(pageSize: number, pageNumber: number, filterBy?: OrderStatus, options?: any): AxiosPromise<OrderListResponse> {
            return localVarFp.getOrderList(pageSize, pageNumber, filterBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order to fulfill for business owner
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {OrderStatus} [filterBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderToFulfillList(pageSize: number, pageNumber: number, filterBy?: OrderStatus, options?: any): AxiosPromise<OrderToFulfillListResponse> {
            return localVarFp.getOrderToFulfillList(pageSize, pageNumber, filterBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get private business analytics
         * @summary Get private business analytics, accessible only by business owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivateBusinessAnalytics(options?: any): AxiosPromise<PrivateBusinessAnalytics> {
            return localVarFp.getPrivateBusinessAnalytics(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Product by id
         * @param {string} productId Product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductById(productId: string, options?: any): AxiosPromise<Product> {
            return localVarFp.getProductById(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get product by business
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {string} businessId Business Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsByBusiness(pageSize: number, pageNumber: number, businessId: string, options?: any): AxiosPromise<ProductListResponse> {
            return localVarFp.getProductsByBusiness(pageSize, pageNumber, businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get public business analytics
         * @summary Get public business analytics
         * @param {string} businessId business id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicBusinessAnalytics(businessId: string, options?: any): AxiosPromise<PublicBusinessAnalytics> {
            return localVarFp.getPublicBusinessAnalytics(businessId, options).then((request) => request(axios, basePath));
        },
        /**
         * get review by id
         * @param {string} businessReviewId review id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewById(businessReviewId: string, options?: any): AxiosPromise<BusinessApplicationReview> {
            return localVarFp.getReviewById(businessReviewId, options).then((request) => request(axios, basePath));
        },
        /**
         * get thread replies page for given thread
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {string} threadId support thread id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreadRepliesPage(pageSize: number, pageNumber: number, threadId: string, options?: any): AxiosPromise<ThreadReplyPageResponse> {
            return localVarFp.getThreadRepliesPage(pageSize, pageNumber, threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user wishlist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWishlist(options?: any): AxiosPromise<Wishlist> {
            return localVarFp.getUserWishlist(options).then((request) => request(axios, basePath));
        },
        /**
         * handle new category application
         * @param {HandleCategoryApplicationRequest} [handleCategoryApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleNewCategoryApplication(handleCategoryApplicationRequest?: HandleCategoryApplicationRequest, options?: any): AxiosPromise<Category> {
            return localVarFp.handleNewCategoryApplication(handleCategoryApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates order to fulfill product status, in case all products have the same status the order status will be updated
         * @param {PatchOrderToFulfillProductStatusRequest} [patchOrderToFulfillProductStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrderToFulfillProductStatus(patchOrderToFulfillProductStatusRequest?: PatchOrderToFulfillProductStatusRequest, options?: any): AxiosPromise<OrderToFulfill> {
            return localVarFp.patchOrderToFulfillProductStatus(patchOrderToFulfillProductStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates order to fulfill and all its related products status
         * @param {PatchOrderToFulfillStatusRequest} [patchOrderToFulfillStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrderToFulfillStatus(patchOrderToFulfillStatusRequest?: PatchOrderToFulfillStatusRequest, options?: any): AxiosPromise<OrderToFulfill> {
            return localVarFp.patchOrderToFulfillStatus(patchOrderToFulfillStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PatchProductRequest} [patchProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProduct(patchProductRequest?: PatchProductRequest, options?: any): AxiosPromise<Product> {
            return localVarFp.patchProduct(patchProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Post product to users cart
         * @param {AddProductToCartRequest} [addProductToCartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductInCart(addProductToCartRequest?: AddProductToCartRequest, options?: any): AxiosPromise<Cart> {
            return localVarFp.postProductInCart(addProductToCartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Rate a product, product should be in the order with status completed
         * @param {RateProductRequest} [rateProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateProduct(rateProductRequest?: RateProductRequest, options?: any): AxiosPromise<Product> {
            return localVarFp.rateProduct(rateProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete current users cart. A empty cart will be recreated and attached to the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recycleCart(options?: any): AxiosPromise<Cart> {
            return localVarFp.recycleCart(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddRemoveProductToWishlistRequest} [addRemoveProductToWishlistRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProductFromWishlist(addRemoveProductToWishlistRequest?: AddRemoveProductToWishlistRequest, options?: any): AxiosPromise<Wishlist> {
            return localVarFp.removeProductFromWishlist(addRemoveProductToWishlistRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Product by text. The searched will be performed based on product name and description
         * @param {string} text Product name and description
         * @param {number} [limitResults] Limit the amount of returned results. Defaults to 5
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAutocompleteProduct(text: string, limitResults?: number, options?: any): AxiosPromise<Array<AutocompleteProductResponseInner>> {
            return localVarFp.searchAutocompleteProduct(text, limitResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Search business
         * @param {string} text Product name or description
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBusiness(text: string, pageSize: number, pageNumber: number, options?: any): AxiosPromise<BusinessForPublicListResponse> {
            return localVarFp.searchBusiness(text, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Search Product by name or description.
         * @param {string} text Product name or description
         * @param {number} pageSize paginationSize
         * @param {number} pageNumber page number
         * @param {SortProductBy} [sortBy] 
         * @param {FilterProductBy} [filterBy] Filter product by category or stock availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProduct(text: string, pageSize: number, pageNumber: number, sortBy?: SortProductBy, filterBy?: FilterProductBy, options?: any): AxiosPromise<ProductListResponse> {
            return localVarFp.searchProduct(text, pageSize, pageNumber, sortBy, filterBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Update business
         * @param {UpdateBusinessRequest} [updateBusinessRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusiness(updateBusinessRequest?: UpdateBusinessRequest, options?: any): AxiosPromise<Business> {
            return localVarFp.updateBusiness(updateBusinessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update business application
         * @param {UpdateBusinessApplicationRequest} [updateBusinessApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessApplication(updateBusinessApplicationRequest?: UpdateBusinessApplicationRequest, options?: any): AxiosPromise<BusinessApplication> {
            return localVarFp.updateBusinessApplication(updateBusinessApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update business application review
         * @param {UpdateBusinessReviewRequest} [updateBusinessReviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessApplicationReview(updateBusinessReviewRequest?: UpdateBusinessReviewRequest, options?: any): AxiosPromise<BusinessApplicationReview> {
            return localVarFp.updateBusinessApplicationReview(updateBusinessReviewRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * update category
         * @param {UpdateCategoryRequest} [updateCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(updateCategoryRequest?: UpdateCategoryRequest, options?: any): AxiosPromise<Category> {
            return localVarFp.updateCategory(updateCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch products in cart
         * @param {UpdateProductInCartRequest} [updateProductInCartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductInCart(updateProductInCartRequest?: UpdateProductInCartRequest, options?: any): AxiosPromise<Cart> {
            return localVarFp.updateProductInCart(updateProductInCartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload company logo for the business application
         * @param {File} [logoFile] Logo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCompanyLogo(logoFile?: File, options?: any): AxiosPromise<BusinessLogo> {
            return localVarFp.uploadCompanyLogo(logoFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload legal documents for the business application
         * @param {File} registrationCertificate Current company status from the Trade Register or Registry Agency
         * @param {File} bankStatement The document is generated by the bank. It is accepted bank statement or screenshot from your online banking, with the name of the company and the IBAN of the company account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLegalDocuments(registrationCertificate: File, bankStatement: File, options?: any): AxiosPromise<BusinessLegalDocuments> {
            return localVarFp.uploadLegalDocuments(registrationCertificate, bankStatement, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProductImage(image: File, options?: any): AxiosPromise<ProductImage> {
            return localVarFp.uploadProductImage(image, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {AddRemoveProductToWishlistRequest} [addRemoveProductToWishlistRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addProductToWishlist(addRemoveProductToWishlistRequest?: AddRemoveProductToWishlistRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addProductToWishlist(addRemoveProductToWishlistRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close support thread
     * @param {CloseSupportThreadRequest} [closeSupportThreadRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public closeSupportThread(closeSupportThreadRequest?: CloseSupportThreadRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).closeSupportThread(closeSupportThreadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new business application
     * @param {CreateBusinessApplicationRequest} [createBusinessApplicationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createBusinessApplication(createBusinessApplicationRequest?: CreateBusinessApplicationRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createBusinessApplication(createBusinessApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new business application review
     * @param {CreateBusinessReviewRequest} [createBusinessReviewRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createBusinessApplicationReview(createBusinessReviewRequest?: CreateBusinessReviewRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createBusinessApplicationReview(createBusinessReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new category application
     * @param {CreateCategoryApplicationRequest} [createCategoryApplicationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createCategoryApplication(createCategoryApplicationRequest?: CreateCategoryApplicationRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createCategoryApplication(createCategoryApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createCheckoutSession(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createCheckoutSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new comment to the post
     * @param {CreateNewCommentRequest} [createNewCommentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createNewComment(createNewCommentRequest?: CreateNewCommentRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createNewComment(createNewCommentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new reply to the comment
     * @param {CreateNewCommentReplyRequest} [createNewCommentReplyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createNewCommentReply(createNewCommentReplyRequest?: CreateNewCommentReplyRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createNewCommentReply(createNewCommentReplyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProductRequest} [productRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createProduct(productRequest?: ProductRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createProduct(productRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user, in case it is already present in the keycloak user database. Endpoint should be called when a user logs in with social identity providers(google,facebook)
     * @param {NewSocialUserRequest} [newSocialUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createSocialUser(newSocialUserRequest?: NewSocialUserRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createSocialUser(newSocialUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create support thread
     * @param {CreateNewSupportThreadRequest} [createNewSupportThreadRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createSupportThread(createNewSupportThreadRequest?: CreateNewSupportThreadRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createSupportThread(createNewSupportThreadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create thread reply for given thread
     * @param {CreateNewThreadReplyRequest} [createNewThreadReplyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createThreadReplyForGivenThread(createNewThreadReplyRequest?: CreateNewThreadReplyRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createThreadReplyForGivenThread(createNewThreadReplyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new user
     * @param {NewUserRequest} [newUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createUser(newUserRequest?: NewUserRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createUser(newUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete category by id for admin
     * @param {string} categoryId categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteCategoryById(categoryId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteCategoryById(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete product by id for admin/business owner
     * @param {string} productId productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteProductById(productId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteProductById(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete current users cart. A empty cart will be recreated and attached to the user
     * @param {DeleteProductInCartRequest} [deleteProductInCartRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteProductInCart(deleteProductInCartRequest?: DeleteProductInCartRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteProductInCart(deleteProductInCartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download legal document
     * @param {string} fileKeyBase64Encoded AWS S3 File key encoded in base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadLegalDocument(fileKeyBase64Encoded: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadLegalDocument(fileKeyBase64Encoded, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get active support thread for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getActiveSupportThreadForCurrentUser(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getActiveSupportThreadForCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get active support thread page
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getActiveSupportThreadPage(pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getActiveSupportThreadPage(pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get archived support thread page
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getArchivedSupportThreadPage(pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getArchivedSupportThreadPage(pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get business application by id
     * @param {string} businessApplicationId id of business application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBusinessApplicationById(businessApplicationId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBusinessApplicationById(businessApplicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get business application list
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBusinessApplicationList(pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBusinessApplicationList(pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get business by id
     * @param {string} businessId business id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBusinessById(businessId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBusinessById(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get business for public by id
     * @param {string} businessId business id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBusinessForPublicById(businessId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBusinessForPublicById(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get business list for admin
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBusinessListForAdmin(pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBusinessListForAdmin(pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get business list
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBusinessListForPublic(pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBusinessListForPublic(pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user cart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCart(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCart(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get category applications list for admin
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCategoryApplicationList(pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCategoryApplicationList(pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get category applications list for admin
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCategoryList(pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCategoryList(pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get comment tree list by product id
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {string} productId product id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCommentTreeListForProduct(pageSize: number, pageNumber: number, productId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCommentTreeListForProduct(pageSize, pageNumber, productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get current authenticated user business information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCurrentUserBusinessInfo(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCurrentUserBusinessInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get current authenticated user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCurrentUserInfo(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCurrentUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get marketplace analytics
     * @summary Get marketplace analytics, accessible only by admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMarketplaceAnalytics(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMarketplaceAnalytics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get customers order list
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {OrderStatus} [filterBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOrderList(pageSize: number, pageNumber: number, filterBy?: OrderStatus, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOrderList(pageSize, pageNumber, filterBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order to fulfill for business owner
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {OrderStatus} [filterBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getOrderToFulfillList(pageSize: number, pageNumber: number, filterBy?: OrderStatus, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getOrderToFulfillList(pageSize, pageNumber, filterBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get private business analytics
     * @summary Get private business analytics, accessible only by business owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPrivateBusinessAnalytics(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPrivateBusinessAnalytics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Product by id
     * @param {string} productId Product id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProductById(productId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProductById(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get product by business
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {string} businessId Business Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProductsByBusiness(pageSize: number, pageNumber: number, businessId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProductsByBusiness(pageSize, pageNumber, businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get public business analytics
     * @summary Get public business analytics
     * @param {string} businessId business id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPublicBusinessAnalytics(businessId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPublicBusinessAnalytics(businessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get review by id
     * @param {string} businessReviewId review id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getReviewById(businessReviewId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getReviewById(businessReviewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get thread replies page for given thread
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {string} threadId support thread id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getThreadRepliesPage(pageSize: number, pageNumber: number, threadId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getThreadRepliesPage(pageSize, pageNumber, threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user wishlist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserWishlist(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserWishlist(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * handle new category application
     * @param {HandleCategoryApplicationRequest} [handleCategoryApplicationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public handleNewCategoryApplication(handleCategoryApplicationRequest?: HandleCategoryApplicationRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).handleNewCategoryApplication(handleCategoryApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates order to fulfill product status, in case all products have the same status the order status will be updated
     * @param {PatchOrderToFulfillProductStatusRequest} [patchOrderToFulfillProductStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public patchOrderToFulfillProductStatus(patchOrderToFulfillProductStatusRequest?: PatchOrderToFulfillProductStatusRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).patchOrderToFulfillProductStatus(patchOrderToFulfillProductStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates order to fulfill and all its related products status
     * @param {PatchOrderToFulfillStatusRequest} [patchOrderToFulfillStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public patchOrderToFulfillStatus(patchOrderToFulfillStatusRequest?: PatchOrderToFulfillStatusRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).patchOrderToFulfillStatus(patchOrderToFulfillStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PatchProductRequest} [patchProductRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public patchProduct(patchProductRequest?: PatchProductRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).patchProduct(patchProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Post product to users cart
     * @param {AddProductToCartRequest} [addProductToCartRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postProductInCart(addProductToCartRequest?: AddProductToCartRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postProductInCart(addProductToCartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rate a product, product should be in the order with status completed
     * @param {RateProductRequest} [rateProductRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rateProduct(rateProductRequest?: RateProductRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rateProduct(rateProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete current users cart. A empty cart will be recreated and attached to the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public recycleCart(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).recycleCart(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddRemoveProductToWishlistRequest} [addRemoveProductToWishlistRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public removeProductFromWishlist(addRemoveProductToWishlistRequest?: AddRemoveProductToWishlistRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).removeProductFromWishlist(addRemoveProductToWishlistRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Product by text. The searched will be performed based on product name and description
     * @param {string} text Product name and description
     * @param {number} [limitResults] Limit the amount of returned results. Defaults to 5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchAutocompleteProduct(text: string, limitResults?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchAutocompleteProduct(text, limitResults, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search business
     * @param {string} text Product name or description
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchBusiness(text: string, pageSize: number, pageNumber: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchBusiness(text, pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search Product by name or description.
     * @param {string} text Product name or description
     * @param {number} pageSize paginationSize
     * @param {number} pageNumber page number
     * @param {SortProductBy} [sortBy] 
     * @param {FilterProductBy} [filterBy] Filter product by category or stock availability.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchProduct(text: string, pageSize: number, pageNumber: number, sortBy?: SortProductBy, filterBy?: FilterProductBy, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchProduct(text, pageSize, pageNumber, sortBy, filterBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update business
     * @param {UpdateBusinessRequest} [updateBusinessRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateBusiness(updateBusinessRequest?: UpdateBusinessRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateBusiness(updateBusinessRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update business application
     * @param {UpdateBusinessApplicationRequest} [updateBusinessApplicationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateBusinessApplication(updateBusinessApplicationRequest?: UpdateBusinessApplicationRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateBusinessApplication(updateBusinessApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update business application review
     * @param {UpdateBusinessReviewRequest} [updateBusinessReviewRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateBusinessApplicationReview(updateBusinessReviewRequest?: UpdateBusinessReviewRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateBusinessApplicationReview(updateBusinessReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update category
     * @param {UpdateCategoryRequest} [updateCategoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateCategory(updateCategoryRequest?: UpdateCategoryRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateCategory(updateCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch products in cart
     * @param {UpdateProductInCartRequest} [updateProductInCartRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateProductInCart(updateProductInCartRequest?: UpdateProductInCartRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateProductInCart(updateProductInCartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload company logo for the business application
     * @param {File} [logoFile] Logo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadCompanyLogo(logoFile?: File, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadCompanyLogo(logoFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload legal documents for the business application
     * @param {File} registrationCertificate Current company status from the Trade Register or Registry Agency
     * @param {File} bankStatement The document is generated by the bank. It is accepted bank statement or screenshot from your online banking, with the name of the company and the IBAN of the company account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadLegalDocuments(registrationCertificate: File, bankStatement: File, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadLegalDocuments(registrationCertificate, bankStatement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} image 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadProductImage(image: File, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadProductImage(image, options).then((request) => request(this.axios, this.basePath));
    }
}


